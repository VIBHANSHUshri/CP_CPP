*********************************************Vectors*****************************************************************

Vectors are one of the most important data structures in C++ as they provide a dynamic array with the ability to resize automatically. A vector can be declared using `vector<int> v;`, which creates an empty vector of integers. If you specify a fixed size during initialization, the vector cannot expand dynamically using `push_back()`, and elements must be inserted using indexing or iterators. However, if you do not specify the size, `push_back()` can be used to dynamically add elements, as vectors automatically adjust their size. When working with matrices, the Standard Template Library (STL) allows us to declare a 2D vector using `vector<vector<int>> v;`, enabling flexible storage and manipulation of multidimensional data. This makes vectors a powerful and versatile tool for handling dynamic data structures efficiently.


#include <iostream>
#include <vector>

using namespace std;

int main() {
    // 1. Vector without predefined size (dynamic growth using push_back)
    vector<int> v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);

    cout << "Vector elements: ";
    for (int num : v) {
        cout << num << " ";
    }
    cout << endl;

    // 2. Vector with predefined size (fixed, elements must be assigned)
    vector<int> v_fixed(3);  // Size = 3, initialized with default values (0)
    v_fixed[0] = 5;
    v_fixed[1] = 15;
    v_fixed[2] = 25;

    cout << "Fixed-size vector elements: ";
    for (int num : v_fixed) {
        cout << num << " ";
    }
    cout << endl;

    // 3. 2D Vector (Matrix)
    vector<vector<int>> matrix(3, vector<int>(3, 0)); // 3x3 matrix initialized with 0s

    // Assigning values to the matrix
    matrix[0][0] = 1;
    matrix[0][1] = 2;
    matrix[0][2] = 3;
    matrix[1][0] = 4;
    matrix[1][1] = 5;
    matrix[1][2] = 6;
    matrix[2][0] = 7;
    matrix[2][1] = 8;
    matrix[2][2] = 9;

    cout << "2D Vector (Matrix):" << endl;
    for (const auto& row : matrix) {
        for (int num : row) {
            cout << num << " ";
        }
        cout << endl;
    }

    return 0;
}


*******************************************************SET***************************************************************

->Unique
->Ordered
->O(logn)

set<int>st;
st.insert(1);
if i insert 1 again nothing will happen , but if i insert another integer then it will insert it into set in sorted Order
basically if you have the st.begin() then this is iterator/ address not a value


set<int>::iterator it = st.begin() -> the correct form writing it
but in new version of c++ we can use auto which replace the set<int>::iterator 

auto adapts with the data type , when we are not sure , or when we need a cleaner code

loop in set

for loop ->

for(auto it = st.begin() ; it!=st.end() ; it++)
{
    cout << *it << " " ;   why we are usign * because we need a value not a address
}

for each loop -> 

for(auto it : st)
{
    cout << it << " ";
}

tc -> nlogn , it++ will take place logn , because of ordering ;
now for n it will take nlogn 


erase in SET                          let set = {1,3,4,7,9}
st.erase(7);
then set will be 1,3,4,9


implementation is based on red black tree , thats why low tc 

tc - O(logn)

there is no index in set , that is why we cannot use 

st.find();


// unordered_set

-> unique values
-> Random order
-> O(1) -> insert find delete 
though some times during collision , 

n -> 10 ^ 5 , logn -> 20

Tip , getting tle on unordered_set -> try using set , 


***************************************************MULTISET***************************************************************
SORTED Order
O(logn)
duplicate values

multiset<int>st;
additional function

st.count(5) then it will the give count of 5

if we want to delete all 5 
st.erase(5) will delete all 5
but what if i need to delete only 1 -> 5
auto it  = st.find(5);

st.erase(it);
or st.erase(st.find(5));

st.clear() -> O(n * logn) -> set multiset
O(n * O(1)) -> unordered_set

   


