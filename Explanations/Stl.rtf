Vectors are one of the most important data structures in C++ as they provide a dynamic array with the ability to resize automatically. A vector can be declared using `vector<int> v;`, which creates an empty vector of integers. If you specify a fixed size during initialization, the vector cannot expand dynamically using `push_back()`, and elements must be inserted using indexing or iterators. However, if you do not specify the size, `push_back()` can be used to dynamically add elements, as vectors automatically adjust their size. When working with matrices, the Standard Template Library (STL) allows us to declare a 2D vector using `vector<vector<int>> v;`, enabling flexible storage and manipulation of multidimensional data. This makes vectors a powerful and versatile tool for handling dynamic data structures efficiently.


#include <iostream>
#include <vector>

using namespace std;

int main() {
    // 1. Vector without predefined size (dynamic growth using push_back)
    vector<int> v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);

    cout << "Vector elements: ";
    for (int num : v) {
        cout << num << " ";
    }
    cout << endl;

    // 2. Vector with predefined size (fixed, elements must be assigned)
    vector<int> v_fixed(3);  // Size = 3, initialized with default values (0)
    v_fixed[0] = 5;
    v_fixed[1] = 15;
    v_fixed[2] = 25;

    cout << "Fixed-size vector elements: ";
    for (int num : v_fixed) {
        cout << num << " ";
    }
    cout << endl;

    // 3. 2D Vector (Matrix)
    vector<vector<int>> matrix(3, vector<int>(3, 0)); // 3x3 matrix initialized with 0s

    // Assigning values to the matrix
    matrix[0][0] = 1;
    matrix[0][1] = 2;
    matrix[0][2] = 3;
    matrix[1][0] = 4;
    matrix[1][1] = 5;
    matrix[1][2] = 6;
    matrix[2][0] = 7;
    matrix[2][1] = 8;
    matrix[2][2] = 9;

    cout << "2D Vector (Matrix):" << endl;
    for (const auto& row : matrix) {
        for (int num : row) {
            cout << num << " ";
        }
        cout << endl;
    }

    return 0;
}


SET 
->Unique
->Ordered
->O(logn)

set<int>st;
st.insert(1);
if i insert 1 again nothing will happen , but if i insert another integer then it will insert it into set in sorted Order
basically if you have the st.begin() then this is iterator/ address not a value
